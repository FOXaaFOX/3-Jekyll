从变量作用域开始谈JS中立即执行函数

1.JS中变量的声明:

既然是从变量作用域开始谈，那么首先说的就是JS中变量的声明

首先JS是弱类型语言（在《JavaSrcipt高级程序设计》中也叫松散类型），在ES5及以前，我们声明变量一般用var，var 可以用来保存任何变量

比如我们声明了一个变量 temp：

    var temp;

在JS中对于声明但是没有赋值的变量，会给一个初始值undefined，好吧，其实我觉得这个undefined这个初始值很有歧义，因为我们明明定义了，只是没赋值而已

而在JS中，当真的使用未定义的变量时，浏览器会报错,提示："is not defined" 如下：

not-defined.png

ps：在JS中允许不定义变量直接对变量进行赋值，而这个变量的作用域，默认为全局作用域

例如：

    a = 123    //那么在整个JS文件中都可以对这个a变量进行访问,这个变量是作用在window对象上的

allscope.png

2.JS中变量的作用域问题：

2.1 JS中的块级区域

在JS中和传统的Java和C++的块级作用域不同，JS中是函数作用域，从ES6中开始有了let 和 const以后，块级作用域开始引入到JS中。

举个栗子：



上图中，scope变量最后输出为"local",说明在块级中，对于scope这个全局变量进行了替换，也就是说

这个被赋值"local"的scope变量，被全局使用了。

另一个栗子：



外部可以访问到块级中的变量，说明块级作用域没有起作用。

2.2 JS中的函数作用域：

JS中函数作用域是指：一个函数作为一个作用域，内层函数可以访问外层函数的变量，外层无法访问内层函数的变量。

(闭包一定程度上，也就是用来解决外层函数访问内层函数变量的问题。)

在JS中使用var定于的变量，没有块级作用域，但是有函数作用域；

在函数作用域中，内层函数可以访问外层函数的变量，如下图。



在函数内会有变量提升的效果，也就是说，在函数内声明的变量，这个声明会自动提升到函数的最上面，提升之后的效果，类似于把声明放到函数作用域最前面；





为什么会有这种提升呢，在文章中介绍：

总所周知js代码自上而下执行，但是在js代码执行前，会先进行词法分析。所以js运行要分为词法分析和执行两个阶段。

　　js词法分析主要分为3个步骤：

　　1，分析形参：如果函数有形参，则给当前活动对象增加形参属性，默认为undefined。

　　2，分析变量声明：如果有类似var a  之类的声明，若没有该属性则增加属性，若已存在则不做操作。默认为undefined。变量的赋值在执行阶段才进行，即执行到该变量的时候才有 var a ＝ 11

　　3，分析函数声明：类似 function a(){}，若当前活动对象没有该属性则新增否则重写该属性为方法a。

也就是说：在作用域内，如果重新声明了这个变量，那么就相当于在当前作用域中抹去了外层变量的声明，是一个新的变量

一个变量提升的对比例子：

￼allscope2.png

如图例子所示：如果在函数作用域中，不对变量声明，仅仅是使用，则不会出现变量声明的覆盖。

3.JS中立即执行函数

解释：js立即执行函数就是让函数在创建后立即执行。

js立即执行函数实现的两种方式：

方式一：整个括号包住函数和执行()

(function(){console.log("函数内容");}()); 

方式二：括号包住函数,在包含括号外+()

(function(){console.log("函数内容");})(); 

立即执行函数的优势：

1.不会产生全局变量，如上面提到的，因为JS是函数作用域，所以在函数内部的变量不会污染到其他作用域的变量。

2.使用立即执行函数，有助于封装某一个模块，因为整个函数是一个命名空间，可迁移性强(前提是你在函数内部，不去使用其他外部的变量，当然，如果你有一个公共的变量文件，你是可以导入进来然后使用的，这个和其他语言中定义common package 是一个意思)。

PS：看过jQuery源码的人都知道，整个jQuery就是一个立即执行函数。

但是有个比较麻烦的地方是，当你想知道立即执行函数传入什么参数的时候，你必须要把很长的一个代码，拉到函数结束才能看到。



IIFE(Immediately Invoked Function Expression):JS中立即执行函数

在说立即执行函数之前，首先要说js中的变量提升原理

变量提升的效果就是把所有的声明都放到了最前面（但是这个声明并不包括赋值语句）


